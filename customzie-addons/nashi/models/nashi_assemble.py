# -*- coding: utf-8 -*-
from datetime import datetime
from odoo import api, fields, models, _
from odoo.exceptions import UserError
from odoo.tools import float_compare, float_round


class Assemble(models.Model):
    _name = "nashi.assemble"
    _description = 'nashi.assemble'

    @api.model
    def _get_default_picking_type(self):
        return self.env['stock.picking.type'].search([
            ('code', '=', 'assem_operation'),
            (
                'warehouse_id.company_id', 'in',
                [self.env.context.get('company_id', self.env.user.company_id.id), False])],
            limit=1).id

    @api.model
    def _get_default_location_src_id(self):
        location = False
        if self._context.get('default_picking_type_id'):
            location = self.env['stock.picking.type'].browse(
                self.env.context['default_picking_type_id']).default_location_src_id
        if not location:
            location = self.env.ref('stock.warehouse0').pba_loc_id
            try:
                location.check_access_rule('read')
            except (AttributeError, AccessError):
                location = self.env['stock.warehouse'].search([('company_id', '=', self.env.user.company_id.id)],
                                                              limit=1).pba_loc_id
        return location and location.id or False

    @api.model
    def _get_default_location_dest_id(self):
        location = False

        location = self.env['stock.warehouse'].search([('company_id', '=', self.env.user.company_id.id)],
                                                      limit=1).saa_loc_id
        return location and location.id or False

    name = fields.Char('Name', readonly=True, index=True, copy=False, default='New')
    user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self._uid)

    state = fields.Selection([
        ('confirmed', 'Confirmed'),
        ('planned', 'Planned'),
        ('progress', 'In Progress'),
        ('done', 'Done'),
        ('cancel', 'Cancelled')], string='State',
        copy=False, default='confirmed', track_visibility='onchange')

    availability = fields.Selection([
        ('assigned', 'Available'),
        ('partially_available', 'Partially Available'),
        ('waiting', 'Waiting'),
        ('none', 'None')], string='Materials Availability',
        compute='_compute_availability', store=True)

    picking_type_id = fields.Many2one(
        'stock.picking.type', 'Operation Type',
        default=_get_default_picking_type, required=True)

    location_src_id = fields.Many2one(
        'stock.location', 'Raw Materials Location',
        default=_get_default_location_src_id,
        readonly=True, required=True,
        states={'confirmed': [('readonly', False)]},
        help="Location where the system will look for components.")
    location_dest_id = fields.Many2one(
        'stock.location', 'Finished Products Location',
        default=_get_default_location_dest_id,
        readonly=True, required=True,
        states={'confirmed': [('readonly', False)]},
        help="Location where the system will stock the finished products.")

    date_planned_start = fields.Datetime(
        'Deadline Start', copy=False, default=fields.Datetime.now,
        index=True, required=True,
        states={'confirmed': [('readonly', False)]}, oldname="date_planned")
    date_planned_finished = fields.Datetime(
        'Deadline End', copy=False, default=fields.Datetime.now,
        index=True,
        states={'confirmed': [('readonly', False)]})

    date_start = fields.Datetime('Start Date', copy=False, index=True, readonly=True)
    date_finished = fields.Datetime('End Date', copy=False, index=True, readonly=True)

    move_pick_ids = fields.One2many(
        'stock.move', 'pick_assemble_id', 'Pick products for assembling',
        copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
        domain=[('scrapped', '=', False)])

    move_return_ids = fields.One2many(
        'stock.move', 'assemble_id', 'Assembled Products',
        copy=False, states={'done': [('readonly', True)], 'cancel': [('readonly', True)]},
        domain=[('scrapped', '=', False)])

    procurement_group_id = fields.Many2one(
        'procurement.group', 'Procurement Group',
        copy=False)

    propagate = fields.Boolean(
        'Propagate cancel and split',
        help='If checked, when the previous move of the move (which was generated by a next procurement) is cancelled or split, the move generated by this move will too')

    user_id = fields.Many2one('res.users', 'Responsible', default=lambda self: self._uid)

    company_id = fields.Many2one(
        'res.company', 'Company',
        default=lambda self: self.env['res.company']._company_default_get('nashi.assemble'),
        required=True)

    check_to_done = fields.Boolean(compute="_get_assembled_qty", string="Check Assembled Qty",
                                   help="Technical Field to see if we can show 'Mark as Done' button")

    is_locked = fields.Boolean('Is Locked', default=True, copy=False)

    pick_lines = fields.One2many('nashi.assemble.pick.line', 'assemble_id', 'Assemble Pick Lines',
                                 copy=True, required=True)
    return_lines = fields.One2many('nashi.assemble.return.line', 'assemble_id', 'Assemble Return Lines',
                                   copy=True, required=True)

    @api.multi
    @api.depends('move_return_ids', 'is_locked')
    def _get_assembled_qty(self):
        for assemble in self:
            all_done = True
            for return_line in assemble.return_lines:
                done_moves = assemble.move_return_ids.filtered(
                    lambda x: x.state != 'cancel' and x.product_id.id == return_line.product_id.id)
                qty_assembled = sum(done_moves.mapped('quantity_done'))
                if qty_assembled < return_line.return_qty:
                    all_done = False
            assemble.check_to_done = assemble.is_locked and all_done and (assemble.state not in ('done', 'cancel'))
        return True

    @api.multi
    @api.depends('move_pick_ids.state')
    def _compute_availability(self):
        for ssemble in self:
            if not ssemble.move_pick_ids:
                ssemble.availability = 'none'
                continue

            ssemble.availability = any(move.state not in ('assigned', 'done', 'cancel') for move in
                                       ssemble.move_pick_ids) and 'waiting' or 'assigned'

    @api.multi
    def button_mark_done(self):
        self.ensure_one()
        moves_to_do = self.move_pick_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
        moves_to_do._action_done()
        moves_to_finish = self.move_return_ids.filtered(lambda x: x.state not in ('done', 'cancel'))
        moves_to_finish._action_done()
        self.action_assign()
        self.write({'state': 'done', 'date_finished': fields.Datetime.now()})
        return self.write({'state': 'done'})


    @api.multi
    def action_assemble(self):
        for return_line in self.return_lines:
            quantity = return_line.return_qty
            for move in self.move_return_ids:
                if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel'):
                    rounding = move.product_uom.rounding
                    if move.product_id.id == return_line.product_id.id:
                        move.quantity_done += float_round(quantity, precision_rounding=rounding)

        for pick_line in self.pick_lines:
            quantity = pick_line.pick_qty
            for move in self.move_pick_ids:
                if move.product_id.tracking == 'none' and move.state not in ('done', 'cancel'):
                    rounding = move.product_uom.rounding
                    if move.product_id.id == pick_line.product_id.id:
                        move.quantity_done += float_round(quantity, precision_rounding=rounding)
        if self.state == 'confirmed':
            self.write({
                'state': 'progress',
                'date_start': datetime.now(),
            })

    @api.multi
    def action_assign(self):
        for assemble in self:
            assemble.move_pick_ids._action_assign()
        return True

    @api.model
    def create(self, values):
        if not values.get('name', False) or values['name'] == _('New'):
            picking_type_id = values.get('picking_type_id') or self._get_default_picking_type()
            picking_type_id = self.env['stock.picking.type'].browse(picking_type_id)
            if picking_type_id:
                values['name'] = picking_type_id.sequence_id.next_by_id()
            else:
                values['name'] = self.env['ir.sequence'].next_by_code('nashi.assemble') or _('New')
        if not values.get('procurement_group_id'):
            values['procurement_group_id'] = self.env["procurement.group"].create({'name': values['name']}).id
        self._check_assemble_vals(values)
        assemble = super(Assemble, self).create(values)
        assemble._generate_moves()
        return assemble

    @api.multi
    def _generate_moves(self):
        for assemble in self:
            assemble._generate_return_moves()
            assemble._generate_pick_moves()
            assemble._adjust_procure_method()
            assemble.move_pick_ids._action_confirm()
        return True

    def _generate_return_moves(self):
        for line in self.return_lines:
            move = self.env['stock.move'].create({
                'name': self.name,
                'date': self.date_planned_start,
                'date_expected': self.date_planned_start,
                'picking_type_id': self.picking_type_id.id,
                'product_id': line.product_id.id,
                'product_uom_qty': line.return_qty,
                'product_uom': line.product_id.uom_id.id,
                'location_id': line.product_id.property_stock_assemble.id,
                'location_dest_id': self.location_dest_id.id,
                'company_id': self.company_id.id,
                'warehouse_id': self.location_dest_id.get_warehouse().id,
                'origin': self.name,
                'group_id': self.procurement_group_id.id,
                'propagate': self.propagate,
                'assemble_id': self.id,
            })
            move._action_confirm()
        return True

    def _generate_pick_moves(self):
        for line in self.pick_lines:
            move = self.env['stock.move'].create({
                'name': self.name,
                'date': self.date_planned_start,
                'date_expected': self.date_planned_start,
                'picking_type_id': self.picking_type_id.id,
                'product_id': line.product_id.id,
                'product_uom_qty': line.pick_qty,
                'product_uom': line.product_id.uom_id.id,
                'location_id': self.location_src_id.id,
                'location_dest_id': line.product_id.property_stock_assemble.id,
                'company_id': self.company_id.id,
                'warehouse_id': self.location_src_id.get_warehouse().id,
                'origin': self.name,
                'group_id': self.procurement_group_id.id,
                'propagate': self.propagate,
                'pick_assemble_id': self.id,
                'procure_method': 'make_to_stock',
            })
        return True

    @api.multi
    def _adjust_procure_method(self):
        try:
            mto_route = self.env['stock.warehouse']._find_global_route('stock.route_warehouse0_mto', _('Make To Order'))
        except:
            mto_route = False
        for move in self.move_pick_ids:
            product = move.product_id
            routes = product.route_ids + product.route_from_categ_ids + move.warehouse_id.route_ids
            pull = self.env['stock.rule'].search(
                [('route_id', 'in', [x.id for x in routes]), ('location_src_id', '=', move.location_id.id),
                 ('location_id', '=', move.location_dest_id.id), ('action', '!=', 'push')], limit=1)
            if pull and (pull.procure_method == 'make_to_order'):
                move.procure_method = pull.procure_method
            elif not pull:  # If there is no make_to_stock rule either
                if mto_route and mto_route.id in [x.id for x in routes]:
                    move.procure_method = 'make_to_order'

    @api.model
    def _check_assemble_vals(self, vals):
        if not vals.get('pick_lines'):
            raise UserError(_('you must set at least one pick product'))
        elif not vals.get('return_lines'):
            raise UserError(_('you must set at least one return product.'))


class AssemblePickLine(models.Model):
    _name = "nashi.assemble.pick.line"
    _description = 'nashi.assemble.pick.line'

    assemble_id = fields.Many2one('nashi.assemble', 'Assemble Order')

    product_id = fields.Many2one('product.product', 'Product', index=True, required=True)
    pick_qty = fields.Float('Pick Quantity', default=1.0, required=True)


class AssembleReturnLine(models.Model):
    _name = "nashi.assemble.return.line"
    _description = 'nashi.assemble.return.line'

    assemble_id = fields.Many2one('nashi.assemble', 'Assemble Order')

    product_id = fields.Many2one('product.product', 'Product', index=True, required=True)
    return_qty = fields.Float('Return Quantity', default=1.0, required=True)
